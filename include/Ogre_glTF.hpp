#pragma once

#include <memory>
#include <Ogre.h>

#include "Ogre_glTF_DLL.hpp"

namespace Ogre_glTF
{
	//Forward declare main class
	class glTFLoader;

	///Plugin accessible interface that plugin users can use
	struct glTFLoaderInterface
	{
		///Polymorphic dtor
		virtual ~glTFLoaderInterface() = default;
		///Get you an item from a GLB file loaded inside an Ogre resource group
		virtual Ogre::Item* getItemFromResource(const std::string& name, Ogre::SceneManager* smgr) = 0;
		///Get you an item from a GLB or a GLTF file from the filesystem.
		virtual Ogre::Item* getItemFromFileSystem(const std::string& fileName, Ogre::SceneManager* smgr) = 0;
	};

	///Class that hold the loaded content of a glTF file and that can create Ogre objects from it
	class Ogre_glTF_EXPORT loaderAdapter
	{
		friend class glTFLoader;

		///opaque content of the class
		struct impl;

		///pointer to implementation
		std::unique_ptr<impl> pimpl;

		std::string adapterName;

	public:
		///This will aslo initialize the "pimpl" structure
		loaderAdapter();

		///This clear the pimpl structure
		~loaderAdapter();

		///Deleted copy constructor : non copyable class
		loaderAdapter(const loaderAdapter&) = delete;

		///Deleted asignment constructor : non copyable class
		loaderAdapter& operator=(const loaderAdapter&) = delete;

		///Construct an item for this object
		/// \param smgr pointer to the scene manager where we are creating the item
		Ogre::Item* getItem(Ogre::SceneManager* smgr) const;

		///Move constructor : object is movable
		/// \param other object to move
		loaderAdapter(loaderAdapter&& other) noexcept;

		///Move assignemnt operator
		loaderAdapter& operator=(loaderAdapter&& other) noexcept;

		///Return the current state of the adapter
		bool isOk() const;

		///Return the last error generated by the underlying glTF loading library
		std::string getLastError() const;
	};

	///Class that is responsible for initializing the library with the loader, and giving out
	class Ogre_glTF_EXPORT glTFLoader final : public glTFLoaderInterface
	{
		///object that acutally communicate with the underlying glTF loading library
		struct glTFLoaderImpl;

		///Opaque pointer that handle the underlying glTF loading library (pimpl)
		std::unique_ptr<glTFLoaderImpl> loaderImpl;

	public:
		///Initialize the library by creating this object.
		glTFLoader();

		///Move constructor
		/// \param other object to move
		glTFLoader(glTFLoader&& other) noexcept;

		glTFLoader& operator=(glTFLoader&& other) noexcept;

		///Deinitialize the library at this object destruction
		~glTFLoader();

		///Load a glTF text or binary file. Give you an adapter to use this file with Ogre
		/// \param path String containing the path to a file to load (either .glTF or .glc)
		loaderAdapter loadFromFileSystem(const std::string& path) const;

		loaderAdapter loadGlbResource(const std::string& name) const;

		Ogre::Item* getItemFromResource(const std::string& name, Ogre::SceneManager* smgr) override;
		Ogre::Item* getItemFromFileSystem(const std::string& fileName, Ogre::SceneManager* smgr) override;

		///Deleted copy contructor
		glTFLoader(const glTFLoader&) = delete;

		///Deleted asignment operator
		glTFLoader& operator=(const glTFLoader&) = delete;
	};
}

//To facilitate the use of the library:
#include "Ogre_glTF_OgreResource.hpp"
#include "Ogre_glTF_OgrePlugin.hpp"
